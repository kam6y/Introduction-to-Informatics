<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Introduction to Informatics</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Zen+Kaku+Gothic+New:wght@400;500;700&family=IBM+Plex+Mono:wght@400;600&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="https://unpkg.com/reveal.js@5/dist/reveal.css" />
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@5/plugin/highlight/monokai.css" />
    <link rel="stylesheet" href="theme/custom.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section class="layout-title">
          <span class="badge">Practical Track</span>
          <h1>Introduction to Informatics</h1>
          <p class="subtitle">Enjoying Coding</p>
          <p class="subtle">180 slides / 480 minutes</p>
        </section>

        <section
          data-markdown="slides/sections.md"
          data-separator="^---$"
        ></section>
      </div>
    </div>

    <script src="https://unpkg.com/reveal.js@5/dist/reveal.js"></script>
    <script src="https://unpkg.com/reveal.js@5/plugin/markdown/markdown.js"></script>
    <script src="https://unpkg.com/reveal.js@5/plugin/notes/notes.js"></script>
    <script src="https://unpkg.com/reveal.js@5/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
      const DIAGRAM_SIZE = { width: 800, height: 320 };

      const getPalette = () => {
        const styles = getComputedStyle(document.documentElement);
        return {
          accent: styles.getPropertyValue("--accent").trim() || "#0f766e",
          accent2: styles.getPropertyValue("--accent-2").trim() || "#d97706",
          accent3: styles.getPropertyValue("--accent-3").trim() || "#2563eb",
          text: styles.getPropertyValue("--text").trim() || "#0f172a",
          muted: styles.getPropertyValue("--muted").trim() || "#5f6b7a",
        };
      };

      const createSvg = (el, label) => {
        const { width, height } = DIAGRAM_SIZE;
        const colors = getPalette();
        el.innerHTML = "";

        const svg = d3
          .select(el)
          .append("svg")
          .attr("viewBox", `0 0 ${width} ${height}`)
          .attr("role", "img")
          .attr("aria-label", label || "");

        const markerId = `arrow-${el.dataset.diagram}`;
        svg
          .append("defs")
          .append("marker")
          .attr("id", markerId)
          .attr("viewBox", "0 0 10 10")
          .attr("refX", 9)
          .attr("refY", 5)
          .attr("markerWidth", 8)
          .attr("markerHeight", 8)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M 0 0 L 10 5 L 0 10 z")
          .attr("fill", colors.accent);

        return { svg, colors, markerId };
      };

      const drawBox = (svg, colors, { x, y, w, h, label, sub, fill, stroke }) => {
        svg
          .append("rect")
          .attr("x", x)
          .attr("y", y)
          .attr("width", w)
          .attr("height", h)
          .attr("rx", 14)
          .attr("fill", fill || "rgba(255, 255, 255, 0.9)")
          .attr("stroke", stroke || colors.accent)
          .attr("stroke-width", 2);

        svg
          .append("text")
          .attr("x", x + w / 2)
          .attr("y", y + h / 2 - (sub ? 6 : 0))
          .attr("text-anchor", "middle")
          .attr("font-size", 18)
          .attr("font-weight", 600)
          .text(label);

        if (sub) {
          svg
            .append("text")
            .attr("x", x + w / 2)
            .attr("y", y + h / 2 + 18)
            .attr("text-anchor", "middle")
            .attr("class", "diagram-sub")
            .text(sub);
        }
      };

      const drawArrow = (svg, colors, { x1, y1, x2, y2, label, markerId, dashed }) => {
        svg
          .append("line")
          .attr("x1", x1)
          .attr("y1", y1)
          .attr("x2", x2)
          .attr("y2", y2)
          .attr("stroke", colors.accent)
          .attr("stroke-width", 2)
          .attr("stroke-dasharray", dashed ? "6 4" : null)
          .attr("marker-end", `url(#${markerId})`);

        if (label) {
          svg
            .append("text")
            .attr("x", (x1 + x2) / 2)
            .attr("y", (y1 + y2) / 2 - 8)
            .attr("text-anchor", "middle")
            .attr("class", "diagram-sub")
            .text(label);
        }
      };

      const drawCommitNode = (svg, colors, x, y, color, label) => {
        svg
          .append("circle")
          .attr("cx", x)
          .attr("cy", y)
          .attr("r", 10)
          .attr("fill", color)
          .attr("stroke", "#ffffff")
          .attr("stroke-width", 2);

        if (label) {
          svg
            .append("text")
            .attr("x", x)
            .attr("y", y + 28)
            .attr("text-anchor", "middle")
            .attr("class", "diagram-sub")
            .text(label);
        }
      };

      const renderRepoMap = (el) => {
        const { svg, colors, markerId } = createSvg(el, "ローカルとリモートの関係");
        const box = { w: 200, h: 80, y: 100 };
        const gap = 60;
        const startX = 40;
        const x1 = startX;
        const x2 = x1 + box.w + gap;
        const x3 = x2 + box.w + gap;

        drawBox(svg, colors, { x: x1, y: box.y, w: box.w, h: box.h, label: "作業ツリー", sub: "edit" });
        drawBox(svg, colors, { x: x2, y: box.y, w: box.w, h: box.h, label: "ローカル履歴", sub: "commit" });
        drawBox(svg, colors, { x: x3, y: box.y, w: box.w, h: box.h, label: "GitHub", sub: "remote" });

        drawArrow(svg, colors, { x1: x1 + box.w, y1: 140, x2: x2, y2: 140, label: "commit", markerId });
        drawArrow(svg, colors, { x1: x2 + box.w, y1: 140, x2: x3, y2: 140, label: "push", markerId });
        drawArrow(svg, colors, { x1: x3, y1: 180, x2: x2 + box.w, y2: 180, label: "pull", markerId });

        svg
          .append("text")
          .attr("x", (x1 + x2 + box.w) / 2)
          .attr("y", 70)
          .attr("text-anchor", "middle")
          .attr("class", "diagram-sub")
          .text("ローカル");
        svg
          .append("text")
          .attr("x", x3 + box.w / 2)
          .attr("y", 70)
          .attr("text-anchor", "middle")
          .attr("class", "diagram-sub")
          .text("リモート");
      };

      const renderBranchMerge = (el) => {
        const { svg, colors } = createSvg(el, "ブランチとマージの流れ");
        const mainY = 80;
        const developY = 160;
        const featureY = 240;
        const mainNodes = [140];
        const developNodes = [220, 360, 540, 660];
        const featureNodes = [320, 420, 520];
        const developStartX = developNodes[0];
        const developMergeX = developNodes[2];
        const featureStartX = featureNodes[0];
        const featureEndX = featureNodes[featureNodes.length - 1];

        svg
          .append("line")
          .attr("x1", 80)
          .attr("y1", mainY)
          .attr("x2", 720)
          .attr("y2", mainY)
          .attr("stroke", colors.accent)
          .attr("stroke-width", 3);

        svg
          .append("line")
          .attr("x1", 140)
          .attr("y1", developY)
          .attr("x2", 680)
          .attr("y2", developY)
          .attr("stroke", colors.accent2)
          .attr("stroke-width", 3);

        svg
          .append("line")
          .attr("x1", featureStartX)
          .attr("y1", featureY)
          .attr("x2", featureEndX)
          .attr("y2", featureY)
          .attr("stroke", colors.accent3)
          .attr("stroke-width", 2.5);

        svg
          .append("line")
          .attr("x1", mainNodes[0])
          .attr("y1", mainY)
          .attr("x2", developStartX)
          .attr("y2", developY)
          .attr("stroke", colors.muted)
          .attr("stroke-width", 2);

        svg
          .append("path")
          .attr(
            "d",
            `M${developStartX} ${developY} C${developStartX + 30} ${developY + 18} ${featureStartX - 30} ${featureY - 32} ${featureStartX} ${featureY}`
          )
          .attr("fill", "none")
          .attr("stroke", colors.accent3)
          .attr("stroke-width", 2.5);

        svg
          .append("path")
          .attr(
            "d",
            `M${featureEndX} ${featureY} C${featureEndX + 20} ${featureY - 10} ${developMergeX - 10} ${developY - 10} ${developMergeX} ${developY}`
          )
          .attr("fill", "none")
          .attr("stroke", colors.accent3)
          .attr("stroke-width", 2.5);

        mainNodes.forEach((x, index) => {
          drawCommitNode(svg, colors, x, mainY, colors.accent, index === 0 ? "main" : "");
        });

        developNodes.forEach((x, index) => {
          drawCommitNode(svg, colors, x, developY, colors.accent2, index === 0 ? "develop" : "");
        });

        featureNodes.forEach((x, index) => {
          drawCommitNode(svg, colors, x, featureY, colors.accent3, index === 0 ? "feature" : "");
        });

        svg
          .append("text")
          .attr("x", developMergeX)
          .attr("y", developY - 25)
          .attr("text-anchor", "middle")
          .attr("class", "diagram-sub")
          .text("merge");
      };

      const renderGitFlow = (el) => {
        const { svg, colors, markerId } = createSvg(el, "Gitの最小フロー");
        const boxDefs = [
          { w: 120, label: "GitHub", sub: "remote" },
          { w: 130, label: "作業ツリー", sub: "edit" },
          { w: 120, label: "ステージ", sub: "add" },
          { w: 130, label: "ローカル履歴", sub: "commit" },
          { w: 120, label: "GitHub", sub: "remote" },
        ];
        const gap = 80;
        const totalWidth = boxDefs.reduce((sum, box) => sum + box.w, 0) + gap * (boxDefs.length - 1);
        const startX = (DIAGRAM_SIZE.width - totalWidth) / 2;
        const y = 90;
        const h = 90;
        const boxes = [];
        let cursorX = startX;

        boxDefs.forEach((box) => {
          drawBox(svg, colors, { x: cursorX, y, w: box.w, h, label: box.label, sub: box.sub });
          boxes.push({ x: cursorX, w: box.w });
          cursorX += box.w + gap;
        });

        drawArrow(svg, colors, { x1: boxes[0].x + boxes[0].w, y1: 135, x2: boxes[1].x, y2: 135, label: "1 pull", markerId });
        drawArrow(svg, colors, { x1: boxes[1].x + boxes[1].w, y1: 135, x2: boxes[2].x, y2: 135, label: "2 add", markerId });
        drawArrow(svg, colors, { x1: boxes[2].x + boxes[2].w, y1: 135, x2: boxes[3].x, y2: 135, label: "3 commit", markerId });
        drawArrow(svg, colors, { x1: boxes[3].x + boxes[3].w, y1: 135, x2: boxes[4].x, y2: 135, label: "4 push", markerId });
      };

      const renderConflict = (el) => {
        const { svg, colors, markerId } = createSvg(el, "コンフリクト解決の流れ");
        drawBox(svg, colors, { x: 80, y: 40, w: 220, h: 80, label: "自分の変更" });
        drawBox(svg, colors, { x: 500, y: 40, w: 220, h: 80, label: "他人の変更" });

        svg
          .append("circle")
          .attr("cx", 400)
          .attr("cy", 160)
          .attr("r", 34)
          .attr("fill", colors.accent2);
        svg
          .append("text")
          .attr("x", 400)
          .attr("y", 168)
          .attr("text-anchor", "middle")
          .attr("font-size", 28)
          .attr("font-weight", 700)
          .attr("fill", "#ffffff")
          .text("!");

        drawArrow(svg, colors, { x1: 300, y1: 120, x2: 370, y2: 150, markerId });
        drawArrow(svg, colors, { x1: 500, y1: 120, x2: 430, y2: 150, markerId });

        drawBox(svg, colors, { x: 260, y: 230, w: 280, h: 80, label: "解決済みコミット", stroke: colors.accent2 });
        drawArrow(svg, colors, { x1: 400, y1: 194, x2: 400, y2: 230, markerId });
      };

      const renderRevert = (el) => {
        const { svg, colors, markerId } = createSvg(el, "リバートの考え方");
        const y = 160;
        svg
          .append("line")
          .attr("x1", 100)
          .attr("y1", y)
          .attr("x2", 660)
          .attr("y2", y)
          .attr("stroke", colors.accent)
          .attr("stroke-width", 3);

        drawCommitNode(svg, colors, 160, y, colors.accent, "A");
        drawCommitNode(svg, colors, 300, y, colors.accent, "B");
        drawCommitNode(svg, colors, 440, y, colors.accent, "C");
        drawCommitNode(svg, colors, 600, y, colors.accent2, "Revert");

        drawArrow(svg, colors, {
          x1: 600,
          y1: 145,
          x2: 440,
          y2: 145,
          markerId,
          dashed: true,
        });

        svg
          .append("text")
          .attr("x", 600)
          .attr("y", 120)
          .attr("text-anchor", "middle")
          .attr("class", "diagram-sub")
          .text("変更を打ち消す");
      };

      const renderStash = (el) => {
        const { svg, colors, markerId } = createSvg(el, "スタッシュの流れ");
        const boxDefs = [
          { w: 220, label: "作業中の変更" },
          { w: 160, label: "stash", sub: "一時退避" },
          { w: 220, label: "作業再開" },
        ];
        const gap = 80;
        const totalWidth = boxDefs.reduce((sum, box) => sum + box.w, 0) + gap * (boxDefs.length - 1);
        const startX = (DIAGRAM_SIZE.width - totalWidth) / 2;
        const y = 110;
        const h = 90;
        const boxes = [];
        let cursorX = startX;

        boxDefs.forEach((box) => {
          drawBox(svg, colors, { x: cursorX, y, w: box.w, h, label: box.label, sub: box.sub });
          boxes.push({ x: cursorX, w: box.w });
          cursorX += box.w + gap;
        });

        drawArrow(svg, colors, { x1: boxes[0].x + boxes[0].w, y1: 155, x2: boxes[1].x, y2: 155, label: "stash", markerId });
        drawArrow(svg, colors, { x1: boxes[1].x + boxes[1].w, y1: 155, x2: boxes[2].x, y2: 155, label: "apply / pop", markerId });
      };

      const renderImageContainer = (el) => {
        const { svg, colors, markerId } = createSvg(el, "イメージとコンテナの関係");
        const imageBox = { x: 70, y: 100, w: 220, h: 120 };
        const containerA = { x: 420, y: 60, w: 260, h: 80 };
        const containerB = { x: 420, y: 180, w: 260, h: 80 };

        drawBox(svg, colors, {
          x: imageBox.x,
          y: imageBox.y,
          w: imageBox.w,
          h: imageBox.h,
          label: "イメージ",
          sub: "テンプレート",
        });
        drawBox(svg, colors, {
          x: containerA.x,
          y: containerA.y,
          w: containerA.w,
          h: containerA.h,
          label: "コンテナA",
          sub: "実行中",
        });
        drawBox(svg, colors, {
          x: containerB.x,
          y: containerB.y,
          w: containerB.w,
          h: containerB.h,
          label: "コンテナB",
          sub: "実行中",
        });

        const imageX = imageBox.x + imageBox.w;
        const imageY = imageBox.y + imageBox.h / 2;

        drawArrow(svg, colors, {
          x1: imageX,
          y1: imageY - 18,
          x2: containerA.x,
          y2: containerA.y + containerA.h / 2,
          label: "run",
          markerId,
        });
        drawArrow(svg, colors, {
          x1: imageX,
          y1: imageY + 18,
          x2: containerB.x,
          y2: containerB.y + containerB.h / 2,
          label: "run",
          markerId,
        });
      };

      const renderRegistryFlow = (el) => {
        const { svg, colors, markerId } = createSvg(el, "ローカルとレジストリと本番の流れ");
        const box = { w: 200, h: 90, y: 110 };
        const gap = 60;
        const x1 = 40;
        const x2 = x1 + box.w + gap;
        const x3 = x2 + box.w + gap;

        drawBox(svg, colors, { x: x1, y: box.y, w: box.w, h: box.h, label: "ローカル/CI", sub: "build" });
        drawBox(svg, colors, { x: x2, y: box.y, w: box.w, h: box.h, label: "レジストリ", sub: "Docker Hub" });
        drawBox(svg, colors, { x: x3, y: box.y, w: box.w, h: box.h, label: "本番環境", sub: "pull" });

        drawArrow(svg, colors, { x1: x1 + box.w, y1: 145, x2: x2, y2: 145, label: "push", markerId });
        drawArrow(svg, colors, { x1: x2, y1: 185, x2: x1 + box.w, y2: 185, label: "pull", markerId });
        drawArrow(svg, colors, { x1: x2 + box.w, y1: 145, x2: x3, y2: 145, label: "pull", markerId });
      };

      const renderWorkflowStructure = (el) => {
        const { svg, colors, markerId } = createSvg(el, "ワークフロー構成図");
        const box = { w: 200, h: 100, y: 110 };
        const gap = 40;
        const totalWidth = box.w * 3 + gap * 2;
        const startX = (DIAGRAM_SIZE.width - totalWidth) / 2;
        const items = [
          { label: "トリガー", sub: "push / PR", fill: "rgba(37, 99, 235, 0.12)", stroke: "#2563eb" },
          { label: "ジョブ", sub: "build / test", fill: "rgba(15, 118, 110, 0.12)", stroke: "#0f766e" },
          { label: "ステップ", sub: "run / uses", fill: "rgba(30, 64, 175, 0.12)", stroke: "#1e40af" },
        ];
        const boxes = [];

        items.forEach((item, index) => {
          const x = startX + index * (box.w + gap);
          drawBox(svg, colors, { x, y: box.y, w: box.w, h: box.h, label: item.label, sub: item.sub, fill: item.fill, stroke: item.stroke });
          boxes.push({ x });
        });

        boxes.forEach((item, index) => {
          if (index === boxes.length - 1) return;
          drawArrow(svg, colors, {
            x1: item.x + box.w,
            y1: box.y + box.h / 2,
            x2: boxes[index + 1].x,
            y2: box.y + box.h / 2,
            markerId,
          });
        });
      };

      const renderCiCdPipeline = (el) => {
        const { svg, colors, markerId } = createSvg(el, "PRから本番までの流れ");
        const box = { w: 120, h: 90, y: 115 };
        const gap = 25;
        const steps = [
          { label: "PR作成", fill: "rgba(37, 99, 235, 0.12)", stroke: "#2563eb" },
          { label: "CI", sub: "build/test", fill: "rgba(15, 118, 110, 0.12)", stroke: "#0f766e" },
          { label: "マージ", sub: "review", fill: "rgba(30, 64, 175, 0.12)", stroke: "#1e40af" },
          { label: "CD", sub: "deploy", fill: "rgba(14, 116, 144, 0.12)", stroke: "#0e7490" },
          { label: "本番", sub: "release", fill: "rgba(59, 130, 246, 0.12)", stroke: "#3b82f6" },
        ];
        const totalWidth = steps.length * box.w + (steps.length - 1) * gap;
        const startX = (DIAGRAM_SIZE.width - totalWidth) / 2;
        const boxes = [];

        steps.forEach((step, index) => {
          const x = startX + index * (box.w + gap);
          drawBox(svg, colors, { x, y: box.y, w: box.w, h: box.h, label: step.label, sub: step.sub, fill: step.fill, stroke: step.stroke });
          boxes.push({ x });
        });

        boxes.forEach((item, index) => {
          if (index === boxes.length - 1) return;
          drawArrow(svg, colors, {
            x1: item.x + box.w,
            y1: box.y + box.h / 2,
            x2: boxes[index + 1].x,
            y2: box.y + box.h / 2,
            markerId,
          });
        });
      };

      const renderTcpIpLayers = (el) => {
        const { svg, colors } = createSvg(el, "TCP/IPの4層モデル");
        const layers = [
          { label: "アプリ層", sub: "HTTP/HTTPS" },
          { label: "トランスポート層", sub: "TCP/UDP" },
          { label: "インターネット層", sub: "IP" },
          { label: "リンク層", sub: "Ethernet/Wi-Fi" },
        ];
        const box = { w: 360, h: 56 };
        const gap = 12;
        const totalHeight = layers.length * box.h + (layers.length - 1) * gap;
        const startY = (DIAGRAM_SIZE.height - totalHeight) / 2;
        const x = (DIAGRAM_SIZE.width - box.w) / 2;

        layers.forEach((layer, index) => {
          const y = startY + index * (box.h + gap);
          drawBox(svg, colors, { x, y, w: box.w, h: box.h, label: layer.label, sub: layer.sub });
        });

        svg
          .append("text")
          .attr("x", x - 18)
          .attr("y", startY + 12)
          .attr("text-anchor", "end")
          .attr("class", "diagram-sub")
          .text("上位");
        svg
          .append("text")
          .attr("x", x - 18)
          .attr("y", startY + totalHeight - 4)
          .attr("text-anchor", "end")
          .attr("class", "diagram-sub")
          .text("下位");
      };

      const renderWebFlow = (el) => {
        const { svg, colors, markerId } = createSvg(el, "Webページ表示の流れ");
        const boxDefs = [
          { label: "ブラウザ", sub: "開始" },
          { label: "DNS", sub: "名前解決" },
          { label: "TCP", sub: "接続" },
          { label: "HTTP", sub: "取得" },
          { label: "表示", sub: "描画" },
        ];
        const box = { w: 110, h: 70, y: 120 };
        const gap = 40;
        const totalWidth = boxDefs.length * box.w + (boxDefs.length - 1) * gap;
        const startX = (DIAGRAM_SIZE.width - totalWidth) / 2;
        const boxes = [];

        boxDefs.forEach((item, index) => {
          const x = startX + index * (box.w + gap);
          drawBox(svg, colors, { x, y: box.y, w: box.w, h: box.h, label: item.label, sub: item.sub });
          boxes.push({ x });
        });

        boxes.forEach((item, index) => {
          if (index === boxes.length - 1) return;
          drawArrow(svg, colors, {
            x1: item.x + box.w,
            y1: box.y + box.h / 2,
            x2: boxes[index + 1].x,
            y2: box.y + box.h / 2,
            markerId,
          });
        });
      };

      const renderClientServer = (el) => {
        const { svg, colors, markerId } = createSvg(el, "クライアントとサーバーの関係");
        const box = { w: 220, h: 90, y: 120 };
        const gap = 160;
        const x1 = (DIAGRAM_SIZE.width - box.w * 2 - gap) / 2;
        const x2 = x1 + box.w + gap;

        drawBox(svg, colors, { x: x1, y: box.y, w: box.w, h: box.h, label: "クライアント", sub: "ブラウザ" });
        drawBox(svg, colors, { x: x2, y: box.y, w: box.w, h: box.h, label: "サーバー", sub: "処理/データ" });

        const midY = box.y + box.h / 2;
        drawArrow(svg, colors, {
          x1: x1 + box.w,
          y1: midY - 18,
          x2,
          y2: midY - 18,
          label: "リクエスト",
          markerId,
        });
        drawArrow(svg, colors, {
          x1: x2,
          y1: midY + 18,
          x2: x1 + box.w,
          y2: midY + 18,
          label: "レスポンス",
          markerId,
        });
      };

      const renderThreeTier = (el) => {
        const { svg, colors, markerId } = createSvg(el, "3層アーキテクチャ");
        const layers = [
          { label: "プレゼンテーション層", sub: "UI/UX" },
          { label: "アプリケーション層", sub: "ビジネスロジック" },
          { label: "データ層", sub: "永続化/DB" },
        ];
        const box = { w: 360, h: 70 };
        const gap = 18;
        const totalHeight = layers.length * box.h + (layers.length - 1) * gap;
        const startY = (DIAGRAM_SIZE.height - totalHeight) / 2;
        const x = (DIAGRAM_SIZE.width - box.w) / 2;
        const boxes = [];

        layers.forEach((layer, index) => {
          const y = startY + index * (box.h + gap);
          drawBox(svg, colors, { x, y, w: box.w, h: box.h, label: layer.label, sub: layer.sub });
          boxes.push({ y });
        });

        boxes.forEach((item, index) => {
          if (index === boxes.length - 1) return;
          drawArrow(svg, colors, {
            x1: x + box.w / 2,
            y1: item.y + box.h,
            x2: x + box.w / 2,
            y2: boxes[index + 1].y,
            markerId,
          });
        });
      };

      const renderApiFlow = (el) => {
        const { svg, colors, markerId } = createSvg(el, "フロントとバックの接続図");
        const items = [
          { label: "フロントエンド", sub: "UI" },
          { label: "API", sub: "契約" },
          { label: "バックエンド", sub: "ロジック" },
          { label: "DB", sub: "永続化" },
        ];
        const box = { w: 150, h: 80, y: 120 };
        const gap = 30;
        const totalWidth = items.length * box.w + (items.length - 1) * gap;
        const startX = (DIAGRAM_SIZE.width - totalWidth) / 2;
        const boxes = [];

        items.forEach((item, index) => {
          const x = startX + index * (box.w + gap);
          drawBox(svg, colors, { x, y: box.y, w: box.w, h: box.h, label: item.label, sub: item.sub });
          boxes.push({ x });
        });

        boxes.forEach((item, index) => {
          if (index === boxes.length - 1) return;
          drawArrow(svg, colors, {
            x1: item.x + box.w,
            y1: box.y + box.h / 2,
            x2: boxes[index + 1].x,
            y2: box.y + box.h / 2,
            markerId,
          });
        });
      };

      const renderCloudResponsibility = (el) => {
        const { svg, colors } = createSvg(el, "クラウド責任共有モデル");
        const columns = [
          { label: "IaaS", userRatio: 0.75, userSub: "アプリ〜OS", providerSub: "インフラ" },
          { label: "PaaS", userRatio: 0.45, userSub: "アプリ/データ", providerSub: "ランタイム〜インフラ" },
          { label: "SaaS", userRatio: 0.28, userSub: "設定", providerSub: "すべて" },
        ];
        const stack = { w: 200, h: 220, y: 70 };
        const gap = 40;
        const totalWidth = columns.length * stack.w + (columns.length - 1) * gap;
        const startX = (DIAGRAM_SIZE.width - totalWidth) / 2;

        columns.forEach((col, index) => {
          const x = startX + index * (stack.w + gap);
          svg
            .append("text")
            .attr("x", x + stack.w / 2)
            .attr("y", stack.y - 18)
            .attr("text-anchor", "middle")
            .attr("font-size", 18)
            .attr("font-weight", 600)
            .text(col.label);

          const userH = Math.round(stack.h * col.userRatio);
          const providerH = stack.h - userH;

          drawBox(svg, colors, {
            x,
            y: stack.y,
            w: stack.w,
            h: userH,
            label: "利用者管理",
            sub: col.userSub,
            fill: "rgba(37, 99, 235, 0.12)",
            stroke: colors.accent3,
          });
          drawBox(svg, colors, {
            x,
            y: stack.y + userH,
            w: stack.w,
            h: providerH,
            label: "クラウド管理",
            sub: col.providerSub,
            fill: "rgba(15, 118, 110, 0.12)",
            stroke: colors.accent,
          });
        });

        svg
          .append("text")
          .attr("x", startX - 12)
          .attr("y", stack.y + 12)
          .attr("text-anchor", "end")
          .attr("class", "diagram-sub")
          .text("上: アプリ");
        svg
          .append("text")
          .attr("x", startX - 12)
          .attr("y", stack.y + stack.h)
          .attr("text-anchor", "end")
          .attr("class", "diagram-sub")
          .text("下: インフラ");
      };

      const diagramRenderers = {
        "repo-map": renderRepoMap,
        "branch-merge": renderBranchMerge,
        "git-flow": renderGitFlow,
        "git-conflict": renderConflict,
        "git-revert": renderRevert,
        "git-stash": renderStash,
        "image-container": renderImageContainer,
        "registry-flow": renderRegistryFlow,
        "workflow-structure": renderWorkflowStructure,
        "cicd-pipeline": renderCiCdPipeline,
        "tcpip-layers": renderTcpIpLayers,
        "web-flow": renderWebFlow,
        "client-server": renderClientServer,
        "three-tier": renderThreeTier,
        "api-flow": renderApiFlow,
        "cloud-responsibility": renderCloudResponsibility,
      };

      const renderDiagrams = (slide) => {
        const targets = (slide || document).querySelectorAll(".diagram[data-diagram]");
        targets.forEach((el) => {
          if (el.dataset.rendered === "true") return;
          const renderer = diagramRenderers[el.dataset.diagram];
          if (!renderer) return;
          renderer(el);
          el.dataset.rendered = "true";
        });
      };

      Reveal.initialize({
        hash: true,
        slideNumber: true,
        width: 1280,
        height: 720,
        margin: 0.08,
        transition: "slide",
        backgroundTransition: "fade",
        plugins: [RevealMarkdown, RevealNotes, RevealHighlight],
      });

      Reveal.on("ready", (event) => {
        renderDiagrams(event.currentSlide);
      });

      Reveal.on("slidechanged", (event) => {
        renderDiagrams(event.currentSlide);
      });
    </script>
  </body>
</html>
